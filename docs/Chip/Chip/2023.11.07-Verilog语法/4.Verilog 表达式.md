# 4. Verilog 表达式

### 表达式

表达式由操作符和操作数构成，其目的是根据操作符的意义得到一个计算结果。表达式可以在出现数值的任何地方使用。例如：

## 实例

```verilog
a^b ;          *//a与b进行异或操作*
address[9:0] + 10'b1 ;  *//地址累加*
flag1 && flag2 ;  *//逻辑与操作*
```

### 操作数

操作数可以是任意的数据类型，只是某些特定的语法结构要求使用特定类型的操作数。

操作数可以为常数，整数，实数，线网，寄存器，时间，位选，域选，存储器及函数调用等。

## 实例

```verilog
module test;
*//实数*
real a, b, c;
c = a + b ;
*//寄存器*
reg  [3:0]       cprmu_1, cprmu_2 ;
always @(posedge clk) begin
        cprmu_2 = cprmu_1 ^ cprmu_2 ;
end
         
*//函数*
reg  flag1 ;
flag = calculate_result(A, B);
 *//非法操作数*
reg [3:0]         res;
wire [3:0]        temp;
always@ （*）begin
    res    = cprmu_2 – cprmu_1 ;
    *//temp = cprmu_2 – cprmu_1 ; //不合法，always块里赋值对象不能是wire型*
end
endmodule
```

### 操作符

Verilog 中提供了大约 9 种操作符，分别是算术、关系、等价、逻辑、按位、归约、移位、拼接、条件操作符。

大部分操作符与 C 语言中类似。同类型操作符之间，除条件操作符从右往左关联，其余操作符都是自左向右关联。圆括号内表达式优先执行。例如下面每组的 2 种写法都是等价的。

```verilog
//自右向左关联，两种写法等价
A+B-C ;
(A+B）-C ;

//自右向左关联，两种写法等价，结果为 B、D 或 F
A ? B : C ? D : F ;
A ? B : (C ? D : F) ;

//自右向左关联，两种写法不等价
(A ? B : C) ? D : F ;  //结果 D 或 F
A ? B : C ? D : F ; //结果为 B、D 或 F
```

不同操作符之间，优先级是不同的。下表列出了操作符优先级从高至低的排列顺序。当没有圆括号时，Verilog 会根据操作符优先级对表达式进行计算。为了避免由操作符优先级导致的计算混乱，在不确定优先级时，建议用圆括号将表达式区分开来。

| 操作符       | 操作符号          | 优先级 |
| ------------ | ----------------- | ------ | --- | --- |
| 单目运算     | + - ! ~           | 最高   |
| 乘、除、取模 | \* / %            |        |
| 加减         | + -               |        |
| 移位         | <<  >>            |        |
| 关系         | <  <=  >  >=      |        |
| 等价         | ==  !=  ===  !=== |        |
| 归约         | & ~&              |        |
|              | ^ ~^              |        |
|              |                   | ~      |     |     |
| 逻辑         | &&                |        |
|              |                   |        |     |     |
| 条件         | ?:                | 最低   |

### 算术操作符

算术操作符包括单目操作符和双目操作符。

双目操作符对 2 个操作数进行算术运算，包括乘（\*）、除（/）、加（+）、减（-）、求幂（）、取模（%）。

## 实例

```verilog
reg [3:0]  a, b;reg [4:0]  c ;
a = 4'b0010 ;
b = 4'b1001 ;
c = a+b;        *//结果为c=b'b1011*
c = a/b;          *//结果为c=4，取整*
```

如果操作数某一位为 X，则计算结果也会全部出现 X。例如：

## 实例

```verilog
b = 4'b100x ;
c = a+b ;       *//结果为c=4'bxxxx*
```

对变量进行声明时，要根据变量的操作符对变量的位宽进行合理声明，不要让结果溢出。上述例子中，相加的 2 个变量位宽为 4bit，那么结果寄存器变量位宽最少为 5bit。否则，高位将被截断，导致结果高位丢失。无符号数乘法时，结果变量位宽应该为 2 个操作数位宽之和。

## 实例

```verilog
reg [3:0]        mula ;reg [1:0]        mulb;reg [5:0]        res ;
mula = 4'he   ;
mulb = 2'h3   ;
res  = mula * mulb ; *//结果为res=6'h2a, 数据结果没有丢失位数*
```

- 和 - 也可以作为单目操作符来使用，表示操作数的正负性。此类操作符优先级最高。

```
-4  //表示负4
+3  //表示正3
```

负数表示时，可以直接在十进制数字前面增加一个减号 -，也可以指定位宽。因为负数使用二进制补码来表示，不指定位宽来表示负数，编译器在转换时，会自动分配位宽，从而导致意想不到的结果。例如：

## 实例

```verilog
mula = -4'd4 ;
mulb = 2 ;
res = mula * mulb ;      *//计算结果为res=-6'd8, 即res=6'h38，正常*
res = mula * (-'d4) ;    *//(4的32次幂-4) * 2, 结果异常*
```

### 关系操作符

关系操作符有大于（>），小于（<），大于等于（>=），小于等于（<=）。

关系操作符的正常结果有 2 种，真（1）或假（0）。

如果操作数中有一位为 x 或 z，则关系表达式的结果为 x。

## 实例

```verilog
A = 4 ;
B = 3 ;
X = 3'b1xx ;
   
A > B     *//为真*
A <= B    *//为假*
A >= Z    *//为X，不确定*
```

### 等价操作符

等价操作符包括逻辑相等（==），逻辑不等（!=），全等（===），非全等（!==）。

等价操作符的正常结果有 2 种：为真（1）或假（0）。

逻辑相等/不等操作符不能比较 x 或 z，当操作数包含一个 x 或 z，则结果为不确定值。

全等比较时，如果按位比较有相同的 x 或 z，返回结果也可以为 1，即全等比较可比较 x 或 z。所以，全等比较的结果一定不包含 x。举例如下：

## 实例

```verilog
A = 4 ;
B = 8'h04 ;
C = 4'bxxxx ;
D = 4'hx ;
A == B        *//为真*
A == (B + 1)  *//为假*
A == C        *//为X，不确定*
A === C       *//为假，返回值为0*
C === D       *//为真，返回值为1*
```

### 逻辑操作符

逻辑操作符主要有 3 个：&&（逻辑与）, ||（逻辑或），!（逻辑非）。

逻辑操作符的计算结果是一个 1 bit 的值，0 表示假，1 表示真，x 表示不确定。

如果一个操作数不为 0，它等价于逻辑 1；如果一个操作数等于 0，它等价于逻辑 0。如果它任意一位为 x 或 z，它等价于 x。

如果任意一个操作数包含 x，逻辑操作符运算结果不一定为 x。

逻辑操作符的操作数可以为变量，也可以为表达式。例如：

## 实例

```verilog
A = 3;
B = 0;
C = 2'b1x ;
   
A && B    *//     为假*
A || B    *//     为真*! A       *//     为假*! B       *//     为真*
A && C    *//     为X，不确定*
A || C    *//     为真，因为A为真*(A==2) && (! B)  *//为真，此时第一个操作数为表达式*
```

### 按位操作符

按位操作符包括：取反（~），与（&），或（|），异或（^），同或（~^）。

按位操作符对 2 个操作数的每 1 bit 数据进行按位操作。

如果 2 个操作数位宽不相等，则用 0 向左扩展补充较短的操作数。

取反操作符只有一个操作数，它对操作数的每 1 bit 数据进行取反操作。

下图给出了按位操作符的逻辑规则。

| &(与） | 0   | 1   | x   |     |     | (或) | 0   | 1   | x   |
| ------ | --- | --- | --- | --- | --- | ---- | --- | --- | --- |
| 0      | 0   | 0   | 0   |     | 0   | 0    | 1   | x   |
| 1      | 0   | 1   | x   |     | 1   | 1    | 1   | 1   |
| x      | 0   | x   | x   |     | x   | x    | 1   | x   |

| ^(异或) | 0   | 1   | x   |     | ~^(同或) | 0   | 1   | x   |
| ------- | --- | --- | --- | --- | -------- | --- | --- | --- |
| 0       | 0   | 1   | x   |     | 0        | 1   | 0   | x   |
| 1       | 1   | 0   | x   |     | 1        | 0   | 1   | x   |
| x       | x   | x   | x   |     | x        | x   | x   | x   |

## 实例

```verilog
A = 4'b0101 ;
B = 4'b1001 ;
C = 4'bx010 ;
~A        *//4'b1010*
A & B     *//4'b0001*
A | B     *//4'b1101*
A^B       *//4'b1100*
A ~^ B    *//4'b0011*
B | C     *//4'b1011*
B&C       *//4'bx000*
```

### 归约操作符

归约操作符包括：归约与（&），归约与非（~&），归约或（|），归约或非（~|），归约异或（^），归约同或（~^）。

归约操作符只有一个操作数，它对这个向量操作数逐位进行操作，最终产生一个 1bit 结果。

逻辑操作符、按位操作符和归约操作符都使用相同的符号表示，因此有时候容易混淆。区分这些操作符的关键是分清操作数的数目，和计算结果的规则。

```verilog
A = 4'b1010 ;
&A ;      //结果为 1 & 0 & 1 & 0 = 1'b0，可用来判断变量A是否全1
~|A ;     //结果为 ~(1 | 0 | 1 | 0) = 1'b0, 可用来判断变量A是否为全0
^A ;      //结果为 1 ^ 0 ^ 1 ^ 0 = 1'b0
```

### 移位操作符

移位操作符包括左移（<<），右移（>>），算术左移（<<<），算术右移（>>>）。

移位操作符是双目操作符，两个操作数分别表示要进行移位的向量信号（操作符左侧）与移动的位数（操作符右侧）。

算术左移和逻辑左移时，右边低位会补 0。

逻辑右移时，左边高位会补 0；而算术右移时，左边高位会补充符号位，以保证数据缩小后值的正确性。

## 实例

```verilog
A = 4'b1100 ;
B = 4'b0010 ;
A = A >> 2 ;        *//结果为 4'b0011*
A = A << 1;         *//结果为 4'b1000*
A = A <<< 1 ;       *//结果为 4'b1000*
C = B + (A>>>2);    *//结果为 2 + (-4/4) = 1, 4'b0001*
```

### 拼接操作符

拼接操作符用大括号 {，} 来表示，用于将多个操作数（向量）拼接成新的操作数（向量），信号间用逗号隔开。

拼接符操作数必须指定位宽，常数的话也需要指定位宽。例如：

## 实例

```verilog
A = 4'b1010 ;
B = 1'b1 ;
Y1 = {B, A[3:2], A[0], 4'h3 };  *//结果为Y1='b1100_0011*
Y2 = {4{B}, 3'd4};  *//结果为 Y2=7'b111_1100*
Y3 = {32{1'b0}};  *//结果为 Y3=32h0，常用作寄存器初始化时匹配位宽的赋初值*
```

### 条件操作符

条件表达式有 3 个操作符，结构描述如下：

```
condition_expression ? true_expression : false_expression
```

计算时，如果 condition_expression 为真（逻辑值为 1），则运算结果为 true_expression；如果 condition_expression 为假（逻辑值为 0），则计算结果为 false_expression。

```verilog
assign hsel    = (addr[9:8] == 2'b0) ? hsel_p1 : hsel_p2 ;
//当信号 addr 高 2bit 为 0 时，hsel 赋值为 hsel_p1; 否则，将 hsel_p2 赋值给 hsel。
```

其实，条件表达式类似于 2 路（或多路）选择器，其描述方式完全可以用 if-else 语句代替。

当然条件操作符也能进行嵌套，完成一个多次选择的逻辑。例如：

## 实例

```verilog
assign   hsel = (addr[9:8] == 2'b00) ? hsel_p1 :
                (addr[9:8] == 2'b01) ? hsel_p2 :
                (addr[9:8] == 2'b10) ? hsel_p3 :
                (addr[9:8] == 2'b11) ? hsel_p4 ;
```
