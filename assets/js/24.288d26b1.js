(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{307:function(a,v,t){a.exports=t.p+"assets/img/10.3fdd2e73.png"},308:function(a,v,t){a.exports=t.p+"assets/img/11.8de292dd.png"},309:function(a,v,t){a.exports=t.p+"assets/img/12.738b1aa1.png"},310:function(a,v,t){a.exports=t.p+"assets/img/13.aeaf6857.png"},412:function(a,v,t){"use strict";t.r(v);var s=t(14),_=Object(s.a)({},(function(){var a=this,v=a._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"_2024-04-02-练习-1-启用编译器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2024-04-02-练习-1-启用编译器"}},[a._v("#")]),a._v(" 2024.04.02-练习 1：启用编译器")]),a._v(" "),v("h2",{attrs:{id:"_1-make"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-make"}},[a._v("#")]),a._v(" 1. make")]),a._v(" "),v("div",{staticClass:"language-cpp extra-class"},[v("pre",{pre:!0,attrs:{class:"language-cpp"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[a._v("main")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" argc"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("char")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v("argv"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),v("span",{pre:!0,attrs:{class:"token function"}},[a._v("puts")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),v("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Hello world."')]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n    "),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),v("p",[a._v("代码段没有显式包含"),v("code",[a._v("#include <stdio.h>")]),a._v("，但是仍然能够运行，并成功调用"),v("code",[a._v("puts")]),a._v('函数输出"Hello world."。这是因为，在某些编译器和开发环境中，即使没有显式地包含标准输入输出头文件'),v("code",[a._v("stdio.h")]),a._v("，编译器也可能会隐式地包含或者提前编译了这些基本的库函数。")]),a._v(" "),v("p",[a._v("具体来说，"),v("code",[a._v("puts")]),a._v("函数是 C 语言标准库中负责输出字符串到标准输出的函数，它定义在"),v("code",[a._v("stdio.h")]),a._v("中。按照 C 语言标准，使用"),v("code",[a._v("puts")]),a._v("或者其他标准库函数时，应该包含相应的头文件。不这样做是不符合标准的，可能导致编译器警告或错误。")]),a._v(" "),v("p",[a._v("然而，一些编译器为了方便开发者，可能会有以下行为：")]),a._v(" "),v("ul",[v("li",[a._v("隐式包含：编译器可能会默认包含一些常用的头文件。这意味着即使开发者没有显式包含"),v("code",[a._v("stdio.h")]),a._v("，编译器也会处理像"),v("code",[a._v("puts")]),a._v("这样的标准库函数调用。")]),a._v(" "),v("li",[a._v("预编译头文件：在某些开发环境中，常用的头文件可能被预编译并隐式地包含在每个编译单元中，以提高编译效率。")]),a._v(" "),v("li",[a._v("特定编译器扩展：一些编译器可能会提供非标准的扩展，允许在没有包含对应头文件的情况下使用某些库函数。")])]),a._v(" "),v("p",[a._v("不过，依赖这种非标准的行为是不推荐的。为了确保代码的可移植性和避免潜在的问题，最佳实践是始终显式包含你在代码中用到的所有标准库头文件。这样做可以保证代码在不同的编译器和环境中都能正常工作。")]),a._v(" "),v("h2",{attrs:{id:"_2-如何使它崩溃"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-如何使它崩溃"}},[a._v("#")]),a._v(" 2. 如何使它崩溃?")]),a._v(" "),v("p",[a._v("对于这个程序，打开所有编译警告重新构建它：")]),a._v(" "),v("div",{staticClass:"language-bash extra-class"},[v("pre",{pre:!0,attrs:{class:"language-bash"}},[v("code",[a._v("$ "),v("span",{pre:!0,attrs:{class:"token function"}},[a._v("rm")]),a._v(" ex1\n$ "),v("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("CFLAGS")]),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),v("span",{pre:!0,attrs:{class:"token string"}},[a._v('"-Wall"')]),a._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[a._v("make")]),a._v(" ex1\ncc "),v("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-Wall")]),a._v("    ex1.c   "),v("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-o")]),a._v(" ex1\nex1.c: Infunction "),v("span",{pre:!0,attrs:{class:"token string"}},[a._v("'main'")]),v("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v(":")]),a._v("\nex1.c:3: warning: implicit declaration offunction "),v("span",{pre:!0,attrs:{class:"token string"}},[a._v("'puts'")]),a._v("\n$ ./ex1\nHello world.\n")])])]),v("p",[v("code",[a._v('CFLAGS="-Wall"')]),a._v("：这部分设置了一个环境变量"),v("code",[a._v("CFLAGS")]),a._v("，它是用于 C 编译器的标志（flags）集合。在这个特定的例子中，"),v("code",[a._v("-Wall")]),a._v("选项被设置给"),v("code",[a._v("CFLAGS")]),a._v("。"),v("code",[a._v("-Wall")]),a._v("是一个编译器标志，告诉编译器生成所有警告信息，帮助开发者发现代码中的潜在问题。这个标志对于提高代码质量和发现潜在的错误非常有用。")]),a._v(" "),v("p",[a._v("现在你会得到一个警告，说"),v("code",[a._v("puts")]),a._v("函数是隐式声明的。C 语言的编译器很智能，它能够理解你想要什么。但是如果可以的话，你应该去除所有编译器警告。把下面一行添加到"),v("code",[a._v("ex1.c")]),a._v("文件的最上面，之后重新编译来去除它：")]),a._v(" "),v("div",{staticClass:"language-c extra-class"},[v("pre",{pre:!0,attrs:{class:"language-c"}},[v("code",[v("span",{pre:!0,attrs:{class:"token macro property"}},[v("span",{pre:!0,attrs:{class:"token directive-hash"}},[a._v("#")]),v("span",{pre:!0,attrs:{class:"token directive keyword"}},[a._v("include")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[a._v("<stdio.h>")])]),a._v("\n")])])]),v("h2",{attrs:{id:"_3-附加题-1"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-附加题-1"}},[a._v("#")]),a._v(" 3. 附加题 1")]),a._v(" "),v("p",[a._v("在你的文本编辑器中打开"),v("code",[a._v("ex1")]),a._v("文件，随机修改或删除一部分，之后运行它看看发生了什么。")]),a._v(" "),v("p",[v("img",{attrs:{src:t(307),alt:"Untitled"}})]),a._v(" "),v("p",[v("img",{attrs:{src:t(308),alt:"Untitled"}})]),a._v(" "),v("h2",{attrs:{id:"_4-附加题-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-附加题-2"}},[a._v("#")]),a._v(" 4. 附加题 2")]),a._v(" "),v("p",[a._v("再多打印 5 行文本或者其它比"),v("code",[a._v('"Hello world."')]),a._v("更复杂的东西。")]),a._v(" "),v("p",[a._v("在 C 语言中，"),v("code",[a._v("char *argv[]")]),a._v("是"),v("code",[a._v("main")]),a._v("函数的一个参数，它表示传递给程序的命令行参数的数组。让我们分解一下这个声明，以便更好地理解它：")]),a._v(" "),v("ul",[v("li",[v("code",[a._v("char")]),a._v("：表示数组中的元素是字符类型。")]),a._v(" "),v("li",[v("code",[a._v("*")]),a._v("：这是一个指针符号，表明这个变量是一个指针。")]),a._v(" "),v("li",[v("code",[a._v("argv[]")]),a._v("：这是一个数组符号，表明这个变量是一个数组。结合前面的指针符号，这意味着"),v("code",[a._v("argv")]),a._v("是一个指向指针的数组，或者更准确地说，是一个指向字符指针的数组。")])]),a._v(" "),v("p",[a._v("所以，"),v("code",[a._v("char *argv[]")]),a._v("是一个指向字符指针数组的指针，每个字符指针指向一个字符串。这些字符串是命令行参数，即在命令行中执行程序时输入的参数。")]),a._v(" "),v("p",[a._v("在"),v("code",[a._v("main")]),a._v("函数的上下文中，"),v("code",[a._v("argc")]),a._v("（argument count）是一个整型（"),v("code",[a._v("int")]),a._v("）变量，它表示命令行参数的数量，包括程序名本身。"),v("code",[a._v("argv")]),a._v("（argument vector）是一个指向字符串数组的指针，存储了所有的命令行参数。"),v("code",[a._v("argv[0]")]),a._v("通常是程序的名称，"),v("code",[a._v("argv[1]")]),a._v("是传递给程序的第一个参数，依此类推。"),v("code",[a._v("argv[argc]")]),a._v("是"),v("code",[a._v("NULL")]),a._v("，标记数组的结束。")]),a._v(" "),v("p",[a._v("举例来说，如果你在命令行中运行程序如下：")]),a._v(" "),v("div",{staticClass:"language-bash extra-class"},[v("pre",{pre:!0,attrs:{class:"language-bash"}},[v("code",[a._v("./myprogram arg1 arg2\n")])])]),v("p",[a._v("这里，"),v("code",[a._v("argc")]),a._v("将是"),v("code",[a._v("3")]),a._v("（因为有三个命令行参数："),v("code",[a._v("./myprogram")]),a._v(", "),v("code",[a._v("arg1")]),a._v(", 和 "),v("code",[a._v("arg2")]),a._v("），而"),v("code",[a._v("argv")]),a._v("数组将包含以下内容：")]),a._v(" "),v("ul",[v("li",[v("code",[a._v("argv[0]")]),a._v(" 将是字符串 "),v("code",[a._v('"./myprogram"')]),a._v("，指向程序的名称。")]),a._v(" "),v("li",[v("code",[a._v("argv[1]")]),a._v(" 将是字符串 "),v("code",[a._v('"arg1"')]),a._v("，指向第一个命令行参数。")]),a._v(" "),v("li",[v("code",[a._v("argv[2]")]),a._v(" 将是字符串 "),v("code",[a._v('"arg2"')]),a._v("，指向第二个命令行参数。")]),a._v(" "),v("li",[v("code",[a._v("argv[3]")]),a._v(" 将是"),v("code",[a._v("NULL")]),a._v("，标记数组的结束。")])]),a._v(" "),v("p",[a._v("通过使用"),v("code",[a._v("argc")]),a._v("和"),v("code",[a._v("argv")]),a._v("，C 程序可以接收和处理用户在命令行中输入的参数。")]),a._v(" "),v("p",[v("img",{attrs:{src:t(309),alt:"Untitled"}})]),a._v(" "),v("h2",{attrs:{id:"_5-附加题-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-附加题-3"}},[a._v("#")]),a._v(" 5. 附加题 3")]),a._v(" "),v("p",[a._v("执行"),v("code",[a._v("man 3 puts")]),a._v("来阅读这个函数和其它函数的文档。")]),a._v(" "),v("p",[a._v("在 UNIX 或类 UNIX 系统中，"),v("code",[a._v("man")]),a._v("命令用于查看手册页（manual pages），它是系统文档的一个重要组成部分。手册页按照不同的部分组织，每个部分涵盖了特定类型的命令或信息。当你在命令行中输入"),v("code",[a._v("man 3 puts")]),a._v("时，"),v("code",[a._v("3")]),a._v("指的是你想要查看第三部分中"),v("code",[a._v("puts")]),a._v("函数的手册页。")]),a._v(" "),v("p",[a._v("手册页的部分主要包括：")]),a._v(" "),v("ol",[v("li",[v("strong",[a._v("用户命令")]),a._v("：可执行程序或 shell 命令。")]),a._v(" "),v("li",[v("strong",[a._v("系统调用")]),a._v("：由内核提供的函数。")]),a._v(" "),v("li",[v("strong",[a._v("库调用")]),a._v("：标准库函数，如 C 库（libc）中的函数。")]),a._v(" "),v("li",[v("strong",[a._v("特殊文件")]),a._v("：通常指/dev 目录下的文件。")]),a._v(" "),v("li",[v("strong",[a._v("文件格式和约定")]),a._v("：例如/etc/passwd。")]),a._v(" "),v("li",[v("strong",[a._v("游戏和屏保")]),a._v("：已经很少使用。")]),a._v(" "),v("li",[v("strong",[a._v("杂项")]),a._v("：包括宏包和约定，如 man 文档自身的格式。")]),a._v(" "),v("li",[v("strong",[a._v("系统管理命令")]),a._v("：通常只能由 root 用户执行的命令。")]),a._v(" "),v("li",[v("strong",[a._v("内核例程")]),a._v("：内核的接口。")])]),a._v(" "),v("p",[a._v("所以，"),v("code",[a._v("man 3 puts")]),a._v("命令表示你请求查看第三部分（库调用）中关于"),v("code",[a._v("puts")]),a._v("函数的文档。"),v("code",[a._v("puts")]),a._v("是标准 C 库的一部分，用于向标准输出写入一个字符串，这就是为什么它位于第三部分。这种组织方法让用户可以快速找到关于不同类型命令和函数的文档，即使它们的名字相同（例如，一个是用户命令，另一个是系统调用）。")]),a._v(" "),v("p",[v("img",{attrs:{src:t(310),alt:"Untitled"}})])])}),[],!1,null,null,null);v.default=_.exports}}]);